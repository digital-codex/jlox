package com.craftinginterpreters.lox;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

class LexerTest {
    @Test
    void test_next() {
        record Test(String input, Token[] expected) {}
        Test[] tests = new Test[]{
                new Test("var five = 5;", new Token[]{
                        new Token(Token.TokenType.VAR, 0, 0, 1, "var"),
                        new Token(Token.TokenType.IDENT, 0, 0, 1, "five"),
                        new Token(Token.TokenType.EQUAL, 0, 0, 1, "="),
                        new Token(Token.TokenType.NUMBER, 0, 0, 1, "5"),
                        new Token(Token.TokenType.SEMICOLON, 0, 0, 1, ";"),
                        new Token(Token.TokenType.EOF, 0, 0, 1, ""),
                }),
                new Test("var ten = 10;", new Token[]{
                        new Token(Token.TokenType.VAR, 0, 0, 1, "var"),
                        new Token(Token.TokenType.IDENT, 0, 0, 1, "ten"),
                        new Token(Token.TokenType.EQUAL, 0, 0, 1, "="),
                        new Token(Token.TokenType.NUMBER, 0, 0, 1, "10"),
                        new Token(Token.TokenType.SEMICOLON, 0, 0, 1, ";"),
                        new Token(Token.TokenType.EOF, 0, 0, 1, ""),
                }),
                new Test("fun add(x, y) { x + y; }", new Token[]{
                        new Token(Token.TokenType.FN, 0, 0, 1, "fun"),
                        new Token(Token.TokenType.IDENT, 0, 0, 1, "add"),
                        new Token(Token.TokenType.LPAREN, 0, 0, 1, "("),
                        new Token(Token.TokenType.IDENT, 0, 0, 1, "x"),
                        new Token(Token.TokenType.COMMA, 0, 0, 1, ","),
                        new Token(Token.TokenType.IDENT, 0, 0, 1, "y"),
                        new Token(Token.TokenType.RPAREN, 0, 0, 1, ")"),
                        new Token(Token.TokenType.LBRACE, 0, 0, 1, "{"),
                        new Token(Token.TokenType.IDENT, 0, 0, 1, "x"),
                        new Token(Token.TokenType.PLUS, 0, 0, 1, "+"),
                        new Token(Token.TokenType.IDENT, 0, 0, 1, "y"),
                        new Token(Token.TokenType.SEMICOLON, 0, 0, 1, ";"),
                        new Token(Token.TokenType.RBRACE, 0, 0, 1, "}"),
                        new Token(Token.TokenType.EOF, 0, 0, 1, ""),
                }),
        };
/*
			`let result = add(five, ten);`,
			[]token.Token{
                {Type: token.LET, Lexeme: "let"},
                {Type: token.IDENT, Lexeme: "result"},
                {Type: token.EQUAL, Lexeme: "="},
                {Type: token.IDENT, Lexeme: "add"},
                {Type: token.LPAREN, Lexeme: "("},
                {Type: token.IDENT, Lexeme: "five"},
                {Type: token.COMMA, Lexeme: ","},
                {Type: token.IDENT, Lexeme: "ten"},
                {Type: token.RPAREN, Lexeme: ")"},
                {Type: token.SEMICOLON, Lexeme: ";"},
                {Type: token.EOF, Lexeme: ""},
            },
            },
            {
			`let zero = 5 - 5 / 5 * 5;`,
			[]token.Token{
                {Type: token.LET, Lexeme: "let"},
                {Type: token.IDENT, Lexeme: "zero"},
                {Type: token.EQUAL, Lexeme: "="},
                {Type: token.NUMBER, Lexeme: "5"},
                {Type: token.MINUS, Lexeme: "-"},
                {Type: token.NUMBER, Lexeme: "5"},
                {Type: token.SLASH, Lexeme: "/"},
                {Type: token.NUMBER, Lexeme: "5"},
                {Type: token.STAR, Lexeme: "*"},
                {Type: token.NUMBER, Lexeme: "5"},
                {Type: token.SEMICOLON, Lexeme: ";"},
                {Type: token.EOF, Lexeme: ""},
            },
            },
            {
			`let less = 5 < 10; let greater = 10 > 5;`,
			[]token.Token{
                {Type: token.LET, Lexeme: "let"},
                {Type: token.IDENT, Lexeme: "less"},
                {Type: token.EQUAL, Lexeme: "="},
                {Type: token.NUMBER, Lexeme: "5"},
                {Type: token.LESS, Lexeme: "<"},
                {Type: token.NUMBER, Lexeme: "10"},
                {Type: token.SEMICOLON, Lexeme: ";"},
                {Type: token.LET, Lexeme: "let"},
                {Type: token.IDENT, Lexeme: "greater"},
                {Type: token.EQUAL, Lexeme: "="},
                {Type: token.NUMBER, Lexeme: "10"},
                {Type: token.MORE, Lexeme: ">"},
                {Type: token.NUMBER, Lexeme: "5"},
                {Type: token.SEMICOLON, Lexeme: ";"},
                {Type: token.EOF, Lexeme: ""},
            },
            },
            {
			`let bool = if (!(5 < 10)) { return true; } else { return false; }`,
			[]token.Token{
                {Type: token.LET, Lexeme: "let"},
                {Type: token.IDENT, Lexeme: "bool"},
                {Type: token.EQUAL, Lexeme: "="},
                {Type: token.IF, Lexeme: "if"},
                {Type: token.LPAREN, Lexeme: "("},
                {Type: token.BANG, Lexeme: "!"},
                {Type: token.LPAREN, Lexeme: "("},
                {Type: token.NUMBER, Lexeme: "5"},
                {Type: token.LESS, Lexeme: "<"},
                {Type: token.NUMBER, Lexeme: "10"},
                {Type: token.RPAREN, Lexeme: ")"},
                {Type: token.RPAREN, Lexeme: ")"},
                {Type: token.LBRACE, Lexeme: "{"},
                {Type: token.RETURN, Lexeme: "return"},
                {Type: token.TRUE, Lexeme: "true"},
                {Type: token.SEMICOLON, Lexeme: ";"},
                {Type: token.RBRACE, Lexeme: "}"},
                {Type: token.ELSE, Lexeme: "else"},
                {Type: token.LBRACE, Lexeme: "{"},
                {Type: token.RETURN, Lexeme: "return"},
                {Type: token.FALSE, Lexeme: "false"},
                {Type: token.SEMICOLON, Lexeme: ";"},
                {Type: token.RBRACE, Lexeme: "}"},
                {Type: token.EOF, Lexeme: ""},
            },
            },
            {
			`let equal = 10 == 10;`,
			[]token.Token{
                {Type: token.LET, Lexeme: "let"},
                {Type: token.IDENT, Lexeme: "equal"},
                {Type: token.EQUAL, Lexeme: "="},
                {Type: token.NUMBER, Lexeme: "10"},
                {Type: token.EQUAL_EQUAL, Lexeme: "=="},
                {Type: token.NUMBER, Lexeme: "10"},
                {Type: token.SEMICOLON, Lexeme: ";"},
                {Type: token.EOF, Lexeme: ""},
            },
            },
            {
			`let not_equal = 10 != 5;`,
			[]token.Token{
                {Type: token.LET, Lexeme: "let"},
                {Type: token.IDENT, Lexeme: "not_equal"},
                {Type: token.EQUAL, Lexeme: "="},
                {Type: token.NUMBER, Lexeme: "10"},
                {Type: token.BANG_EQUAL, Lexeme: "!="},
                {Type: token.NUMBER, Lexeme: "5"},
                {Type: token.SEMICOLON, Lexeme: ";"},
                {Type: token.EOF, Lexeme: ""},
            },
            },
            {
			`let foobar = "foobar"; let foo_bar = "foo bar";`,
			[]token.Token{
                {Type: token.LET, Lexeme: "let"},
                {Type: token.IDENT, Lexeme: "foobar"},
                {Type: token.EQUAL, Lexeme: "="},
                {Type: token.STRING, Lexeme: "foobar"},
                {Type: token.SEMICOLON, Lexeme: ";"},
                {Type: token.LET, Lexeme: "let"},
                {Type: token.IDENT, Lexeme: "foo_bar"},
                {Type: token.EQUAL, Lexeme: "="},
                {Type: token.STRING, Lexeme: "foo bar"},
                {Type: token.SEMICOLON, Lexeme: ";"},
                {Type: token.EOF, Lexeme: ""},
            },
            },
            {
			`let array = [5, 10];`,
			[]token.Token{
                {Type: token.LET, Lexeme: "let"},
                {Type: token.IDENT, Lexeme: "array"},
                {Type: token.EQUAL, Lexeme: "="},
                {Type: token.LBRACKET, Lexeme: "["},
                {Type: token.NUMBER, Lexeme: "5"},
                {Type: token.COMMA, Lexeme: ","},
                {Type: token.NUMBER, Lexeme: "10"},
                {Type: token.RBRACKET, Lexeme: "]"},
                {Type: token.SEMICOLON, Lexeme: ";"},
                {Type: token.EOF, Lexeme: ""},
            },
            },
            {
			`let map = {"foo": "bar"};`,
			[]token.Token{
                {Type: token.LET, Lexeme: "let"},
                {Type: token.IDENT, Lexeme: "map"},
                {Type: token.EQUAL, Lexeme: "="},
                {Type: token.LBRACE, Lexeme: "{"},
                {Type: token.STRING, Lexeme: "foo"},
                {Type: token.COLON, Lexeme: ":"},
                {Type: token.STRING, Lexeme: "bar"},
                {Type: token.RBRACE, Lexeme: "}"},
                {Type: token.SEMICOLON, Lexeme: ";"},
                {Type: token.EOF, Lexeme: ""},
            },
            },
            {
			`let sub = macro(x, y) { quote(unquote(x) - unquote(y)); }`,
			[]token.Token{
                {Type: token.LET, Lexeme: "let"},
                {Type: token.IDENT, Lexeme: "sub"},
                {Type: token.EQUAL, Lexeme: "="},
                {Type: token.MACRO, Lexeme: "macro"},
                {Type: token.LPAREN, Lexeme: "("},
                {Type: token.IDENT, Lexeme: "x"},
                {Type: token.COMMA, Lexeme: ","},
                {Type: token.IDENT, Lexeme: "y"},
                {Type: token.RPAREN, Lexeme: ")"},
                {Type: token.LBRACE, Lexeme: "{"},
                {Type: token.IDENT, Lexeme: "quote"},
                {Type: token.LPAREN, Lexeme: "("},
                {Type: token.IDENT, Lexeme: "unquote"},
                {Type: token.LPAREN, Lexeme: "("},
                {Type: token.IDENT, Lexeme: "x"},
                {Type: token.RPAREN, Lexeme: ")"},
                {Type: token.MINUS, Lexeme: "-"},
                {Type: token.IDENT, Lexeme: "unquote"},
                {Type: token.LPAREN, Lexeme: "("},
                {Type: token.IDENT, Lexeme: "y"},
                {Type: token.RPAREN, Lexeme: ")"},
                {Type: token.RPAREN, Lexeme: ")"},
                {Type: token.SEMICOLON, Lexeme: ";"},
                {Type: token.RBRACE, Lexeme: "}"},
                {Type: token.EOF, Lexeme: ""},
            },
            },
        }
*/
        for (int i = 0; i < tests.length; ++i) {
            Lexer lexer = new Lexer(tests[i].input, Assertions::fail);
            for (Token expected : tests[i].expected) {
                Token actual = lexer.next();
                Assertions.assertEquals(expected.type(), actual.type(), "test[" + i + "] - Type wrong");
                Assertions.assertEquals(expected.lexeme(), actual.lexeme(), "test[" + i + "] - Lexeme wrong");
            }
        }
    }
}